#pragma once

#include "seri/rendering/RenderingManagerBase.h"

#include <glad/gl.h>

#include <utility>
#include <stdexcept>

namespace seri
{
	class RenderingManagerOpenGL : public RenderingManagerBase
	{
	public:
		RenderingManagerOpenGL() = default;

		~RenderingManagerOpenGL() override
		{
			LOGGER(info, "[rendering] opengl rendering manager destroyed");
		}

		void Init(std::unique_ptr<WindowManagerBase>& windowManager) override
		{
			if (_initialized)
			{
				throw std::runtime_error("[rendering] opengl rendering manager is already initialized");
			}

			windowManager->SetOpenGLHints();
			windowManager->SetOpenGLContext();
			LoadGlad(windowManager);
			SetOpenGLOptions();
			LogOpenGLInfo();
			EnableOpenGLDebugOutput();

			_initialized = true;

			LOGGER(info, "[rendering] opengl rendering manager successfully");
		}

		void SetViewport(int x, int y, int width, int height) override
		{
			glViewport(x, y, width, height);
		}

		void Clear() override
		{
			const unsigned int mask = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT;
			glClear(mask);
		}

		void ClearColor(float red = 0.2f, float green = 0.2f, float blue = 0.2f, float alpha = 1.0f) override
		{
			glClearColor(red, green, blue, alpha);
		}

		void SetPointSize(float size) override
		{
			glPointSize(size);
		}

		void SetLineWidth(float width) override
		{
			glLineWidth(width);
		}

		DepthFunc GetDepthFunc() override
		{
			GLint depthFunc;
			glGetIntegerv(GL_DEPTH_FUNC, &depthFunc);

			switch (depthFunc)
			{
				case GL_NEVER: return DepthFunc::never;
				case GL_ALWAYS: return DepthFunc::always;
				case GL_LESS: return DepthFunc::less;
				case GL_EQUAL: return DepthFunc::equal;
				case GL_LEQUAL: return DepthFunc::l_equal;
				case GL_GEQUAL: return DepthFunc::g_equal;
				case GL_GREATER: return DepthFunc::greater;
				case GL_NOTEQUAL: return DepthFunc::not_equal;
			}

			return DepthFunc::less;
		}

		DepthFunc SetDepthFunc(bool enabled, DepthFunc depthFunc) override
		{
			DepthFunc old = GetDepthFunc();
			if (enabled)
			{
				glEnable(GL_DEPTH_TEST);
				glDepthMask(GL_TRUE);
				glDepthFunc(GetDepthFunc(depthFunc));
				return old;
			}
			else
			{
				glDisable(GL_DEPTH_TEST);
				glDepthMask(GL_FALSE);
				return old;
			}
		}

		void SetDepthWrite(bool enabled) override
		{
			if (enabled)
			{
				glEnable(GL_DEPTH_TEST);
			}
			else
			{
				glDisable(GL_DEPTH_TEST);
			}
		}

		void SetBlend(bool enabled, BlendFactor srcFactor, BlendFactor dstFactor) override
		{
			if (enabled)
			{
				glEnable(GL_BLEND);
				glBlendFunc(GetBlendFactor(srcFactor), GetBlendFactor(dstFactor));
			}
			else
			{
				glDisable(GL_BLEND);
			}
		}

		void SetCullFace(bool enabled, CullFace cullFace) override
		{
			if (enabled)
			{
				glEnable(GL_CULL_FACE);
				glCullFace(GetCullFace(cullFace));
			}
			else
			{
				glDisable(GL_CULL_FACE);
			}
		}

		void SetFrontFace(FrontFace frontFace) override
		{
			glFrontFace(GetFrontFace(frontFace));
		}

	protected:
		void LoadGlad(std::unique_ptr<WindowManagerBase>& windowManager)
		{
			int version = gladLoadGL(static_cast<GLADloadfunc>(windowManager->GetOpenGLProcAddress()));
			if (version == 0)
			{
				throw std::runtime_error("[rendering] glad load error");
			}

			LOGGER(info, "[rendering] loaded opengl " << GLAD_VERSION_MAJOR(version) << "." << GLAD_VERSION_MINOR(version));
		}

		void SetOpenGLOptions()
		{
			glEnable(GL_BLEND);
			glEnable(GL_DEPTH_TEST);
			//glEnable(GL_FRAMEBUFFER_SRGB);
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		}

		void LogOpenGLInfo()
		{
			LOGGER(info, "[rendering] vendor: " << glGetString(GL_VENDOR));
			LOGGER(info, "[rendering] version: " << glGetString(GL_VERSION));
			LOGGER(info, "[rendering] renderer: " << glGetString(GL_RENDERER));
			LOGGER(info, "[rendering] shading language version: " << glGetString(GL_SHADING_LANGUAGE_VERSION));
		}

		void CheckOpenGLError()
		{
			GLenum err;
			while ((err = glGetError()) != GL_NO_ERROR)
			{
				LOGGER(error, "[rendering] gl error occurred: " << err);
			}
		}

		void EnableOpenGLDebugOutput()
		{
			static const auto getDebugSourceString = [](GLenum source)
				{
					if (source == GL_DEBUG_SOURCE_API)
					{
						return "Calls to the OpenGL API";
					}
					if (source == GL_DEBUG_SOURCE_WINDOW_SYSTEM)
					{
						return "Calls to a window-system API";
					}
					if (source == GL_DEBUG_SOURCE_SHADER_COMPILER)
					{
						return "A compiler for a shading language";
					}
					if (source == GL_DEBUG_SOURCE_THIRD_PARTY)
					{
						return "An application associated with OpenGL";
					}
					if (source == GL_DEBUG_SOURCE_APPLICATION)
					{
						return "Generated by the user of this application";
					}
					if (source == GL_DEBUG_SOURCE_OTHER)
					{
						return "Some source that isn't one of these";
					}

					return "Unknown source";
				};

			static const auto getDebugTypeString = [](GLenum type)
				{
					if (type == GL_DEBUG_TYPE_ERROR)
					{
						return "An error, typically from the API";
					}
					if (type == GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR)
					{
						return "Some behavior marked deprecated has been used";
					}
					if (type == GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR)
					{
						return "Something has invoked undefined behavior";
					}
					if (type == GL_DEBUG_TYPE_PORTABILITY)
					{
						return "Some functionality the user relies upon is not portable";
					}
					if (type == GL_DEBUG_TYPE_PERFORMANCE)
					{
						return "Code has triggered possible performance issues";
					}
					if (type == GL_DEBUG_TYPE_MARKER)
					{
						return "Command stream annotation";
					}
					if (type == GL_DEBUG_TYPE_PUSH_GROUP)
					{
						return "Group pushing";
					}
					if (type == GL_DEBUG_TYPE_POP_GROUP)
					{
						return "Group popping";
					}
					if (type == GL_DEBUG_TYPE_OTHER)
					{
						return "Some type that isn't one of these";
					}

					return "Unknown type";
				};

			static const auto getDebugSeverityString = [](GLenum severity)
				{
					if (severity == GL_DEBUG_SEVERITY_HIGH)
					{
						return "All OpenGL Errors, shader compilation / linking errors, or highly - dangerous undefined behavior";
					}
					else if (severity == GL_DEBUG_SEVERITY_MEDIUM)
					{
						return "Major performance warnings, shader compilation / linking warnings, or the use of deprecated functionality";
					}
					else if (severity == GL_DEBUG_SEVERITY_LOW)
					{
						return "Redundant state change performance warning, or unimportant undefined behavior";
					}
					else if (severity == GL_DEBUG_SEVERITY_NOTIFICATION)
					{
						return "Anything that isn't an error or performance issue";
					}

					return "Unknown source";
				};

			glEnable(GL_DEBUG_OUTPUT);
			glDebugMessageCallback(
				[](GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam)
				{
					if (severity == GL_DEBUG_SEVERITY_NOTIFICATION)
					{
						return;
					}

					LOGGER(debug, "[rendering] gl debug message:" << "\n"
						<< "severity: " << getDebugSeverityString(severity) << "\n"
						<< "type: " << getDebugTypeString(type) << "\n"
						<< "source: " << getDebugSourceString(source) << "\n"
						<< "id: " << id << "\n"
						<< "message: " << message << "\n"
					);
				},
				nullptr
			);
		}

		void DisableOpenGLDebugOutput()
		{
			glDisable(GL_DEBUG_OUTPUT);
		}

		GLenum GetCullFace(CullFace cullFace)
		{
			switch (cullFace)
			{
				case CullFace::front: return GL_FRONT;
				case CullFace::back: return GL_BACK;
				case CullFace::front_and_back: return GL_FRONT_AND_BACK;
			}
			return GL_BACK;
		}

		GLenum GetFrontFace(FrontFace frontFace)
		{
			switch (frontFace)
			{
				case FrontFace::cw: return GL_CW;
				case FrontFace::ccw: return GL_CCW;
			}
			return GL_CCW;
		}

		GLenum GetDepthFunc(DepthFunc depthFunc)
		{
			switch (depthFunc)
			{
				case DepthFunc::never: return GL_NEVER;
				case DepthFunc::always: return GL_ALWAYS;
				case DepthFunc::less: return GL_LESS;
				case DepthFunc::equal: return GL_EQUAL;
				case DepthFunc::l_equal: return GL_LEQUAL;
				case DepthFunc::g_equal: return GL_GEQUAL;
				case DepthFunc::greater: return GL_GREATER;
				case DepthFunc::not_equal: return GL_NOTEQUAL;
			}
			return GL_LESS;
		}

		GLenum GetBlendFactor(BlendFactor factor)
		{
			switch (factor)
			{
				case BlendFactor::zero: return GL_ZERO;
				case BlendFactor::one: return GL_ONE;
				case BlendFactor::src_color: return GL_SRC_COLOR;
				case BlendFactor::one_minus_src_color: return GL_ONE_MINUS_SRC_COLOR;
				case BlendFactor::dst_color: return GL_DST_COLOR;
				case BlendFactor::one_minus_dst_color: return GL_ONE_MINUS_DST_COLOR;
				case BlendFactor::src_alpha: return GL_SRC_ALPHA;
				case BlendFactor::one_minus_src_alpha: return GL_ONE_MINUS_SRC_ALPHA;
				case BlendFactor::dst_alpha: return GL_DST_ALPHA;
				case BlendFactor::one_minus_dst_alpha: return GL_ONE_MINUS_DST_ALPHA;
				case BlendFactor::constant_color: return GL_CONSTANT_COLOR;
				case BlendFactor::one_minus_constant_color: return GL_ONE_MINUS_CONSTANT_COLOR;
				case BlendFactor::constant_alpha: return GL_CONSTANT_ALPHA;
				case BlendFactor::one_minus_constant_alpha: return GL_ONE_MINUS_CONSTANT_ALPHA;
				case BlendFactor::src_alpha_saturate: return GL_SRC_ALPHA_SATURATE;
			}

			return GL_ONE;
		}

	};
}
